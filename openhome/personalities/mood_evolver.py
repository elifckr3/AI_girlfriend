import requests
from openhome.utility import write_json
import json 
import openhome.app_globals
from openhome.LLM import chatgpt
import re
from time import sleep

def average_dict_values(current_mood_dict, mood_json):
    """This function takes to dictionaries with same keys to average them.

    Args:
        current_mood_dict (dict): Current mood returned from mood_detector function.
        mood_json (dict): Mood dictionary from mood.json/averaged mood dictioanry

    Returns:
        averaged_dict (dict): Average mood dictionary to be stored in mood.json
    """
    # Step  1: Initialize an empty dictionary
    averaged_dict = {}
    
    # Step  2: Iterate over the current_mood_dict dictionary
    for key, value in current_mood_dict.items():
        # Check if the key exists in the mood_json dictionary
        if key in mood_json:
            # Calculate the average
            avg_value = (mood_json[key] + value) /  2
            # Update the larger dictionary with the average value
            mood_json[key] = avg_value        
    # Step  5: Return the new dictionary
    return mood_json

def sort_dictionary(average_mood_dict):
    """
    This function takes a dictinary and returned its descending order sorted version.

    Args:
        average_mood_dict (dict): Dictionary to be sorted in descending order

    Returns:
        sorted_dict (dict): Sorted dictionary.
    """
    # Sort dictionary by value in descending order
    sorted_dict = sorted(average_mood_dict.items(), key=lambda x: x[1], reverse=True)
    # Convert the sorted list of tuples 
    # back into a dictionary
    sorted_dict = dict(sorted_dict)
    # return the sorted dictionary.
    return sorted_dict

def string_to_dict(string_input):
    """
    The function takes input that is generated by chatgpt. Chatgpt provide responses as string.
    The purpose is to convert string to dictionary.
    Args:
        string_input: Input message received from chatgpt.

    Returns:
        percentage_dict = Dict containing emotions and scores.
    """
    # Define a regex pattern to find the keys and scores
    pattern = r"(- )(\w+) (\d+)%"
    matches = re.findall(pattern, string_input)

    # Create a dictionary from the matches
    emotions_dict = {key.strip('- '): int(score) for _, key, score in matches}

    return emotions_dict
   
def mood_evolver(mood_prompt_template, api_key, emotion_detection_prompt):
    """
    This is the escence model of this module. taht call all other functions to create a customizable prompt.

    Args:
        user_latest_message (str): Latest user message.
        mood_json (dict): It is a dictioanry from mood.json or averaged json.
        instructions (str): Instruction string from mood evolving instruction text file.

    Returns:
        prompt (str): Customized prompt only for mood.
        average_mood_dict (dict): Dictioanry to be passed in next iteration to forbide file reading again and again.
    """
    # while True:
    conversation = openhome.app_globals.conversation
    mood_json = openhome.app_globals.mood_json
    # call chatgpt function for emotion detection
    emotion = chatgpt(api_key, conversation, emotion_detection_prompt)

    # Convert emotion and scores in dict
    emotions_with_scores = string_to_dict(emotion)
    print('current moode scores', emotions_with_scores)
    average_mood_dict = average_dict_values(emotions_with_scores, mood_json)
    average_mood_dict = sort_dictionary(average_mood_dict)
    print('Averaged', average_mood_dict)
    # store average mood dictonary to our json
    write_json(path='openhome/personalities/mood.json', data=average_mood_dict)
    # store current mood dictonary to our json
    write_json(path='openhome/personalities/current_mood.json', data=emotions_with_scores)
    # prepare prompt
    # get keys of sorted average dictionary into list to get them by index.
    moods_values = list(average_mood_dict.keys())
    # check if modes_values has three or more classes/values in it.
    try:
        # get emotion with heighest score.
        max_score_class = moods_values[0]
        # get emotion with second heighest score.
        second_max_score_class = moods_values[1]
        # get emotion with third heighest score.
        third_max_score_class = moods_values[2]
    # In exception case put the first class in all modes.
    except Exception as e:
        # get emotion with heighest score.
        max_score_class = moods_values[0]
        # get emotion with second heighest score.
        second_max_score_class = moods_values[0]
        # get emotion with third heighest score.
        third_max_score_class = moods_values[0] 
    prompt = mood_prompt_template.format(max_score_class = max_score_class, 
                                second_max_score_class = second_max_score_class,
                                third_max_score_class = third_max_score_class )
    openhome.app_globals.mood_json = average_mood_dict
    openhome.app_globals.customized_mood_prompt = prompt
    # sleep(5)


def get_customized_prompt(initial_prompt):
    """
    This function takes two prompts and join them as one single prompt to be passed to chatgpt function.

    Args:
        mood_prompt (str): Customized mood propmt generated through mood eveloer funtion.
        initial_prompt (str): Initial personality propmt

    Returns:
        prompt: prompt to begiven to chatgpt, combination of customized mood prompt and initla prompt.
    """
    mood_prompt = openhome.app_globals.customized_mood_prompt
    prompt = initial_prompt + " " + mood_prompt
    return prompt
